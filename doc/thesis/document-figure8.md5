\begingroup \toks 0={macro:->[timing/table,]\coordinate (@last row) at (0,\rowdist ); \coordinate (label@header) at ($ -1*(\tikztiming@coldist ,0) + 1.5*(0,\tikztiming@rowdist ) $); \coordinate (diagram@header) at ($ 1.5*(0,\tikztiming@rowdist ) $); \coordinate (timing@table@bottom right) at (0,0); \coordinate (timing@table@bottom left) at ($ -1*(\tikztiming@coldist ,0) $); \tikztiming@picinit \tikzset {timing/before table}\tikztimingtable@checkrow SYNC & H 32{L} H \\ SCLK & C 16{2C} N(A1) C \\ DIN & 2{L} {2H} N(B1) 15{2L} \\ Data & 2D{} 2D{1} 2D{} 2D{0} 2D{} 2D{0} 2D{} 2D{0} 2D{} 2D{0} 2D{} 2D{0} 2D{} 2D{0} 2D{} 2D{0} 2D{}\\ \end {tikztimingtable} \caption {Example Timing diagram: data input starts when (SYNC) is pulled low. On falling edges of (SCLK), (DIN) is read. If (DIN) is high at that moment, the bit is 1, if low it is 0. After eight bits are transferred, (SYNC) is pulled high again and the data transfer is finished. The resulting state is a closed first switch while all other switches are open.} \label {fig:msc} \end {center} \end {figure} \par Multiple matrix switches can be controlled at once by daisy-chaining the data output pin (DOUT) of the first device to DIN of the second one, and on so forth. Both SYNC and SCLK are connected to the same bus. This assures that all matrix switches are set in the same state and at the same time and is important for our use case to synchronize the two used ADG378 parts. \par \section {MinieC Interface} \par The MinieC Interface contains the electronics to perform the resistance measurement. It contains several parts used to generate an electrical signal, run it through a circuit in which the liquid to be measured serves as a resistor and measure the voltage drop over it.\\ \par The first part is a TPS6040 charge pump voltage inverter. It's purpose is to generate a negative output voltage from a positive input. This negative voltage and the positive voltage are needed to drive a Wien bridge oscillator. This oscillator outputs a sine wave voltage oscillating between the positive and negative input voltage. This whole first stages purpose is to generate an alternating current to be used in the measurement, avoiding the polarization effects described before.\\ \par The AC signal provided by the first stage is then fed into an operational amplifier (opamp). An opamp is a part that has two input signals and one output, where the output is proportional to the difference of the input signals. In our use case, the opamp's output is pulled to ground via a voltage divider as shown in Figure \ref {fig:opamp}. The first resistor $R_i$ in the divider is fixed, while the second one $R$ is the liquid to be measured. The output voltage of this divider is depended on the liquids resistance. This voltage is then fed back into the second input of the OpAmp. Via this feedback, the output (OUT) of the opamp is now the input signal (SIG) modulated in amplitude by the resistance of the liquid. \par \begin {figure}[H] \begin {center} \begin {circuitikz} \draw (0,0) node[op amp, yscale=-1](oa1) {} (0,0) node[] {OA} (oa1.+) node[left] {SIG} (oa1.out) to[R=$R_i$] +(0,-2) coordinate (fb) to[vR=$R$] +(0,-2) to +(0,0) node[ground] {} (fb) to[short, o-] +(-3,2) coordinate (i1) (oa1.-) to[short] +(0,1.5) coordinate (i2) (i1) to (i2) (oa1.out) to[short, o-] +(1,0) coordinate (out) (out) node[right] {OUT} ; \end {circuitikz} \caption {The opamp (OA) modulates the input signals (SIG) amplitude proportional to the variable resistance $R$ in the voltage divider to generate the output (OUT).} \label {fig:opamp} \end {center} \end {figure} \par In the last step, the modulated output is amplified in two stages, filtered, and then measured by an analog-digital-converter (ADC). The ADC measures the voltage and provides the measurement to the microcontroller via I2C.\\ \par First tests of the interface surfaced an interesting problem. The graph displayed in figure \ref {fig:swcap} shows the response to an immediate switch from the AC input signal to zero. The first red line marks the moment of the switch, the second line marks the moment when the response reached the voltage zero. The red dot marks the moment when the response reached the midpoint between the old and new input. It took \unit [40]{ms} for the response to follow the input. This slow response time is not acceptable in our system because it prohibits the rapid switching between sensors needed for the fast sampling of data. The slow response would smear the measurement over all sensors and it would not be possible to measure a difference between them. Waiting for that amount of time between each read of a sensor would reduce the time resolution to a level where the desired information can no longer be extracted from the data. The cause of this behavior is the filter placed before the ADC. As the output of the OpAmp is an alternating current, a diode and a filter capacitor are used to generate a direct current signal proportional to the amplitude of the AC signal. This is done so the sample rate of the ADC does not have to match the frequency of the signal, which makes it easier to use when fast sampling rates are not necessary.\\ \par \begin {figure} \begin {center} \input {images/log_12052016_1} \caption {The blue graph shows the measured voltage with a resistance of 0. At the first red line, a switch breaks the connection, making the resistance infinite. The voltage drops slowly towards zero and reaches the new value after \unit [0.04]{s}, marked by the second red line.} \label {fig:swcap} \end {center} \end {figure} \par Figure \ref {fig:swnocap} shows the response to the same switching as before, but with the filter capacitor removed. The diode is still in place and removes the negative voltages from the output. Without the capacitor however, the signal oscillates with the same \unit [1666]{Hz} as the Wien bridge oscillator provides. Because the sample rate of the ADC is not as fast as the oscillation, it measures at random moments on the sine wave, resulting in an output that moves between zero and the maximum amplitude. The red line again marks the moment of the switch and it can be clearly seen that the response delay is now gone. The oscillating behavior that was electrically filtered before is now visible and has to be addressed in the data analysis which will be described later in the Section \ref {val} Validation. \par \begin {figure} \begin {center} \input {images/log_12052016_2} \caption {The scatter plot shows the signal oscillating between 0 and the voltage at a resistance of 0. The red line marks the breaking of the connection. The signal follows without delay.} \label {fig:swnocap} \end {center} \end {figure} \par \section {Microcontroller} \label {uc} \par The microcontroller has to be able to control the functions of the sensor nodes attached to it, read the data from them, log it and serve it to the user-interface. They usually are programmed in C or C++, however in recent years other options emerged. One of those is \textcite {upy}, which is an implementation of the Python 3 programming language designed to run on microcontrollers. As a scripting language Python is a vastly easier language to work with than C/C++, and helps to sped up the development process. Scripting languages also often are familiar from usage for data processing and visualization. Using MicroPython allows us to design a system where it is more likely that the people using it are able to quickly understand the code, enabling them to improve it and adapt it to alternate use-cases. It does however limit our choice of hardware to supported platforms and it requires more powerful and thereby expensive micro-controllers. But as the system only requires one microcontroller to drive a very large amount of sensors, the added cost is relative and outweighed by the benefits of the better usability.\\ \par For prototyping, a development board named "Espruino Pico" was chosen. It is a very small and simple board that provides the electrical boilerplate to use a micro-controller without needing to deal with the lowest level of electronics. It provides a stable power supply and a USB connection to a host PC for programming and to export the collected data. \par \section {Carrier Board} \par The carrier board is a simple printed circuit board (PCB) implementing all parts described above. Figure \ref {fig:cb} shows the assembled board. On the left, the Espruino Pico board can either be soldered directly to the PCB or plugged in using pin header connectors. Above and beyond used pins are replicated on through-holes. This allows for easy connection of measurement equipment to debug the system during development, but can also be used later to connect carrier boards together. Only one would carry a microcontroller and control the other connected boards. \par In the middle there are two matrix switches. They can either be directly soldered on as in this image or they can be soldered to an adapter board that is again mounted to the carrier with pin header connectors in the inner rows of through-holes. The outer through-holes are where the connectors for the cables to the sensors are mounted. \par The MineeC is located on the right side. It also can be either directly soldered or used with pin header connectors. Additionally, two wires have to be run to the carrier board because of an misalignment of ports due to a design error. \par The design is tailored for use as a prototype. That means that everything is made bigger than necessary, which allows for easier modifications. All used pins are replicated on additional through-holes, making them accessible for measuring equipment like an oscilloscope or multimeter. It is also kept modular, so that each part can be swapped out separately. A later redesign would integrate all boards into one and try to reduce size, which in turn saves money on PCB manufacturing. However, the prototype showed no critical design errors and is fully functional, so the next design step is only necessary when more boards are needed. \par \begin {figure} \begin {center} \includegraphics [width=0.8\textwidth ]{images/cb.jpg} \caption {The assembled carrier board with all parts directly soldered on.} \label {fig:cb} \end {center} \end {figure} \par \section {Embedded Software} \par The embedded software is the program running on the microcontroller. As already described in Section \ref {uc} Microcontroller, MicroPython is used to implement this program.\\ \par As soon as the system is powered up, it starts listening for the Start and Stop commands from the OpenSalinity GUI running on the host PC. Communication happens via a serial connection on the USB port. Once a Start command is received, polling of the sensors is started and the data is delivered to the PC, where it is captured and stored. In order to poll the sensors, the program has to control the switches and the ADC. It first switches both matrix switches to a certain electrode pair and then reads the ADC value for it. After that it switches to the next pair and thus cycles through all connected sensors. Each ADC read is accompanied by a time stamp for the read. During all this the device keeps listening for signals from the GUI in an asynchronous fashion. A stop signal can be received at any time and is executed immediately.\\ \par The data is sent in a simple format described in the Listing \ref {lst:format}. One line contains timestamps and values for all $n$ connected sensors separated by one whitespace. The line ends with the newline character. \par \begin {lstlisting}[caption={The data format contains timestamps and values seperated by a whitespace.},label={lst:format}] <time 1> <value 1> <time 2> <value 2> ... <time n> <value n> \n <time 1> <value 1> <time 2> <value 2> ... <time n> <value n> \n ... \end {lstlisting} \par \begin {figure} \begin {center} \begin {tikzpicture}[scale=1, rect/.style={minimum width={width("timestamp")+16pt}}] \node [style=scircle, inner sep=6pt, fill=Green!20!White, draw=Green!20!White,align=center, minimum width={width("control")+12pt},] (0) at (0, 16) {power:\\on}; \node [style=scircle, inner sep=6pt, fill=Green!20!White, draw=Green!20!White, align=center] (1) at (0, 12.5) {control:\\start}; \node [style=diamond, inner sep=8pt, align=center, fill=Blue!20!White, draw=Blue!20!White] (2) at (0, 9) {if i < n}; \node [style=rect, inner sep=8pt, align=center, fill=Yellow!20!White, draw=Yellow!20!White] (3) at (0, 6) {switch to\\sensor i}; \node [style=rect, inner sep=8pt, align=center, fill=Yellow!20!White, draw=Yellow!20!White] (4) at (0, 4) {read ADC}; \node [style=rect, inner sep=8pt, align=center, fill=Yellow!20!White, draw=Yellow!20!White] (5) at (0, 2) {create\\timestamp}; \node [style=rect, inner sep=8pt, align=center, fill=Blue!20!White, draw=Blue!20!White] (6) at (0, 0) {i++}; \node [style=rect, inner sep=8pt, align=center, fill=Yellow!20!White, draw=Yellow!20!White] (7) at (4, 9) {send data\\to GUI}; \node [style=rect, inner sep=8pt, align=center, fill=Blue!20!White, draw=Blue!20!White] (8) at (4, 11) {i = 0}; \par \node [style=scircle, inner sep=6pt, fill=Red!20!White, draw=Red!20!White,align=center, minimum width={width("control")+12pt},] (100) at (-7, 16) {power:\\off}; \par \node [style=scircle, inner sep=6pt, fill=Green!20!White, draw=Green!20!White,align=center, minimum width={width("control")+12pt},] (200) at (-4, 16) {power:\\on}; \node [style=scircle, inner sep=6pt, fill=Red!20!White, draw=Red!20!White, align=center] (201) at (-4, 12.5) {control:\\stop}; \par \draw [style=arrow, ultra thick] (0) to (1); \draw [style=arrow, ultra thick] (200) to (201); \draw [style=arrow, ultra thick] (1) to (2); \draw [style=arrow, ultra thick] (2) to node[right] {true} (3); \draw [style=arrow, ultra thick] (3) to (4); \draw [style=arrow, ultra thick] (6) to (-2,0) to (-2,9) to (2); \draw [style=arrow, ultra thick] (4) to (5); \draw [style=arrow, ultra thick] (5) to (6); \draw [style=arrow, ultra thick] (2) to node[below] {false} (7); \draw [style=arrow, ultra thick] (7) to (8); \draw [style=simple, ultra thick] (8) to (0,11); \draw [dashed] (-5.5,17) -- (-5.5,-0.5); \draw [dashed] (-2.5,17) -- (-2.5,-0.5); }\xdef \tikzexternallastkey {\the \toks 0 }\endgroup %
